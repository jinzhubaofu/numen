{"version":3,"sources":["Locator.js"],"names":["Location","toQueryString","guid","addQuery","PUSH","REPLACE","TRAVEL","Locator","onLocationChange","bind","listeners","interceptors","currentLocation","stack","e","transit","getLocation","Error","start","nextLocation","id","on","handler","push","off","filter","item","redirect","url","query","force","title","replace","reload","equalTo","notifyAll","intercept","ok","finishTransit","action","currentLocationIndex","getLocationIndex","nextLocationIndex","go","location","indexOf","slice","concat","forEach","listener","getLength","length","delta","window","history","back","forward","createHref","pathname","index","connector","use","interceptor","callback","current","isDone","done","next","update","nextQuery","dispose","stop","module","exports"],"mappings":"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","file":"Locator.js","sourcesContent":["/**\n * @file Locator\n * @author leon(ludafa@outlook.com)\n */\n\nconst Location =  require('./Location');\n\nconst {\n    toQueryString,\n    guid,\n    addQuery\n} = require('./util');\n\nconst {\n    PUSH,\n    REPLACE,\n    TRAVEL\n} = require('./action');\n\n/**\n * 定位器\n *\n * @abstract\n */\nclass Locator {\n\n    /**\n     * 构造函数\n     *\n     * @public\n     */\n    constructor() {\n        this.onLocationChange = this.onLocationChange.bind(this);\n        this.listeners = [];\n        this.interceptors = [];\n        this.currentLocation = null;\n        this.stack = [];\n    }\n\n    /**\n     * 地址发生变化时处理函数\n     *\n     * @param {Object} e 地址变化事件\n     * @protected\n     */\n    onLocationChange(e) {\n        this.transit(this.getLocation(e));\n    }\n\n    /**\n     * 获取当前地址\n     *\n     * @abstract\n     * @return {Location}\n     */\n    getLocation() {\n        throw new Error('history.getLocation() need implement');\n    }\n\n    /**\n     * 开始监听\n     *\n     * @public\n     */\n    start() {\n        let nextLocation = this.getLocation();\n        this.stack = [nextLocation.id];\n        this.transit(nextLocation);\n    }\n\n    /**\n     * 添加事件监听\n     *\n     * @public\n     * @param {Function} handler 回调函数\n     * @return {Locator}\n     */\n    on(handler) {\n        this.listeners.push(handler);\n        return this;\n    }\n\n    /**\n     * 移除事件监听\n     *\n     * @public\n     * @param {Function} handler 回调函数\n     * @return {Locator}\n     */\n    off(handler) {\n        this.listeners = this.listeners.filter(function (item) {\n            return item !== handler;\n        });\n        return this;\n    }\n\n    /**\n     * 跳转\n     *\n     * @public\n     * @param {string}   url   url\n     * @param {?Object}  query query\n     * @param {?boolean} force 强制跳转（即使当前 Location 与即将转向的 Location 一致仍触发 change 事件）\n     * @param {?string}  title 标题\n     */\n    redirect(url, query = {}, force = false, title = '') {\n        let nextLocation = new Location(\n            addQuery(url, query),\n            PUSH,\n            guid(),\n            title\n        );\n        this.transit(nextLocation, force);\n    }\n\n    /**\n     * 替换当前地址\n     *\n     * @public\n     * @param {string}   url   url\n     * @param {?Object}  query query\n     * @param {?boolean} force 强制跳转（即使当前 Location 与即将转向的 Location 一致仍触发 change 事件）\n     * @param {?string}  title 标题\n     */\n    replace(url, query = {}, force = false, title = '') {\n        let nextLocation = new Location(\n            addQuery(url, query),\n            REPLACE,\n            guid(),\n            title\n        );\n        this.transit(nextLocation, force);\n    }\n\n    /**\n     * 重载\n     *\n     * @public\n     */\n    reload() {\n        this.transit(this.getLocation(), true);\n    }\n\n    /**\n     * 转向\n     *\n     * @param {Location} nextLocation 下一下地址\n     * @param {boolean}  force        强制转转\n     */\n    transit(nextLocation, force) {\n\n        let currentLocation = this.currentLocation;\n\n        if (currentLocation && currentLocation.equalTo(nextLocation)) {\n            if (force) {\n                this.notifyAll(nextLocation);\n            }\n            return;\n        }\n\n        this.intercept(nextLocation, ok => {\n\n            // 如果跳转没有被拦截，那么我们就完成之\n            if (ok) {\n                this.finishTransit(nextLocation);\n                return;\n            }\n\n            // 如果被跳转被挡截下来，那么我们就要滚回去\n            // 这里处理TRAVEL类型，原因是如果是PUSH/REPLACE，我们在这里并不会调用`finisihTransit`了，也就没有效果\n            if (nextLocation.action !== TRAVEL) {\n                return;\n            }\n\n            // 接下来我们要计算滚回几步\n            // 计算的办法是这样的：\n            // 首先找到当前的地址序号，再找到一下地址的序号\n            // 对于 TRAVEL back 操作来讲，比如 1 -> 2 -> 3\n            // 然后在back操作会导致3状态(currentLocation)回到2状态(nextLocation)\n            // 下一个地址有可能已经在我们的栈中了。\n            // 因此，在这种情况下 nextLocationIndex 是小于 currentLocationIndex的\n            // 那么两者的差值就是我们需要回滚的步数。\n\n            let currentLocationIndex = currentLocation\n                ? this.getLocationIndex(currentLocation)\n                : -1;\n\n            // 接下来找到下一个地址在栈中的位置\n\n            let nextLocationIndex = this.getLocationIndex(nextLocation);\n\n            if (\n                currentLocationIndex === -1\n                || nextLocationIndex === -1\n            ) {\n                return;\n            }\n\n            // 因为我们在这里直接给滚回去了，\n            // 所以会因为上边的currentLocation是一样的，就不会再有后边的操作啦\n            // 因此我们也不会触发回调了\n            this.go(currentLocationIndex - nextLocationIndex);\n\n            return;\n\n        });\n\n    }\n\n    /**\n     * 获取地地址在历史栈中的序号\n     *\n     * @protected\n     * @param {Location} location 地址\n     * @return {number}\n     */\n    getLocationIndex(location) {\n        return this.stack.indexOf(location.id);\n    }\n\n    /**\n     * 更新当前的URL\n     *\n     * 基类中的此接口有两个功能\n     *\n     * 1. 更新历史记录栈\n     * 2. 触发侦听函数\n     * 3. 更新当前地址\n     *\n     * @param {module:Location} nextLocation 下一个location\n     */\n    finishTransit(nextLocation) {\n\n        let {currentLocation, stack} = this;\n\n        let {action, id} = nextLocation;\n\n        let currentLocationIndex = currentLocation\n            ? this.getLocationIndex(currentLocation)\n            : -1;\n\n        // 这里只处理`产生`历史记录的操作(PUSH/REPLACE)，TRAVEL对应的是回退/前进，并不影响栈\n        switch (action) {\n            case PUSH:\n                this.stack = currentLocationIndex === -1\n                    ? [id]\n                    : stack.slice(0, currentLocationIndex + 1).concat(id);\n                break;\n            case REPLACE:\n                if (currentLocationIndex !== -1) {\n                    this.stack[currentLocationIndex] = id;\n                }\n                break;\n        }\n\n        this.notifyAll(nextLocation);\n\n        this.currentLocation = nextLocation;\n\n    }\n\n    /**\n     * 触发回调\n     *\n     * @protected\n     * @param {module:Location} nextLocation 下一个地址\n     */\n    notifyAll(nextLocation) {\n        // 触发回调\n        this.listeners.forEach(function (listener) {\n            listener(nextLocation);\n        });\n    }\n\n    /**\n     * 获取历史栈的长度\n     *\n     * @return {number}\n     */\n    getLength() {\n        return this.stack.length;\n    }\n\n    /**\n     * 前向/前后指定步数\n     *\n     * 基本等同于 window.location.go\n     *\n     * @public\n     * @param {number} delta 步数\n     */\n    go(delta) {\n        if (delta) {\n            window.history.go(delta);\n        }\n    }\n\n    /**\n     * 回退\n     *\n     * @public\n     */\n    back() {\n        this.go(-1);\n    }\n\n    /**\n     * 前进\n     *\n     * @public\n     */\n    forward() {\n        this.go(1);\n    }\n\n    /**\n     * 生成 href\n     *\n     * @public\n     * @param {string}  pathname pathname\n     * @param {?Object} query    query\n     * @return {string}\n     */\n    createHref(pathname, query) {\n        let index = pathname.indexOf('?');\n        let connector = index === -1 ? '?' : '&';\n        return pathname + connector + toQueryString(query);\n    }\n\n    /**\n     * 添加拦截器\n     *\n     * @public\n     * @param {Function} interceptor 拦截器\n     * @return {module:Locator}\n     */\n    use(interceptor) {\n        this.interceptors.push(interceptor);\n        return this;\n    }\n\n    /**\n     * 拦截\n     *\n     * 按照用户指定的拦截器栈的顺序，依次调用拦截器；\n     *\n     * @protected\n     * @param  {module:Location} nextLocation 下一个地址\n     * @param  {Function}        callback     完成时回调函数\n     * @return {module:Locator}\n     */\n    intercept(nextLocation, callback) {\n\n        let current = 0;\n        let isDone = false;\n        let interceptors = this.interceptors.slice();\n\n        function done(ok) {\n            isDone = true;\n            callback(ok);\n        }\n\n        function next() {\n\n            if (isDone || current === interceptors.length) {\n                isDone = true;\n                callback(true);\n                return;\n            }\n\n            let interceptor = interceptors[current++];\n            interceptor(nextLocation, next, done);\n        }\n\n        next();\n\n        return this;\n\n    }\n\n    /**\n     * 按指定的 query 生成一个新的 href，并跳转到新 href\n     *\n     * @public\n     * @param {Object} nextQuery 合并的 query\n     */\n    update(nextQuery) {\n\n        let {pathname, query, title} = this.currentLocation;\n\n        this.redirect(\n            pathname,\n            {\n                ...query,\n                ...nextQuery\n            },\n            false,\n            title\n        );\n\n    }\n\n    /**\n     * 析构\n     *\n     * @public\n     */\n    dispose() {\n        this.stop();\n        this.listeners.length = 0;\n    }\n\n}\n\nmodule.exports = Locator;\n"],"sourceRoot":"/source/"}